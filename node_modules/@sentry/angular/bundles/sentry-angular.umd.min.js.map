{"version":3,"sources":["../../src/constants.ts","../../src/flags.ts","../../src/zone.ts","../../src/errorhandler.ts","../../src/tracing.ts","../../src/sdk.ts"],"names":["ANGULAR_INIT_OP","IS_DEBUG_BUILD","__SENTRY_DEBUG__","isNgZoneEnabled","Zone","current","runOutsideAngular","callback","root","run","instrumentationInitialized","stashedStartTransaction","stashedStartTransactionOnLocationChange","SentryErrorHandler","options","this","_options","Object","assign","logErrors","prototype","handleError","error","extractedError","_extractError","eventId","captureException","scope","addEventProcessor","event","addExceptionMechanism","type","handled","console","showDialog","Sentry","showReportDialog","dialogOptions","extractor","defaultExtractor","_defaultExtractor","bind","errorCandidate","ngOriginalError","Error","HttpErrorResponse","ErrorEvent","message","status","Injectable","args","providedIn","undefined","decorators","Inject","global","getGlobalObject","routingInstrumentation","customStartTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","location","name","pathname","op","metadata","source","instrumentAngularRouting","getActiveTransaction","currentHub","getCurrentHub","getScope","getTransaction","TraceService","_router","_this","navStart$","events","pipe","filter","NavigationStart","tap","navigationEvent","strippedUrl","stripUrlQueryAndFragment","url","activeTransaction","_routingSpan","finish","startChild","description","tags","navigationTrigger","logger","resEnd$","ResolveEnd","route","getParameterizedRouteFromSnapshot","state","transaction","setName","navEnd$","NavigationEnd","_subscription","Subscription","add","subscribe","ngOnDestroy","unsubscribe","Router","TraceDirective","componentName","ngOnInit","_tracingSpan","ngAfterViewInit","Directive","selector","Input","TraceModule","path","firstChild","routeConfig","NgModule","declarations","exports","tracingSpan","target","originalOnInit","_i","arguments","length","apply","originalAfterViewInit","propertyKey","descriptor","originalMethod","value","now","timestampWithMs","constructor","endTimestamp","ANGULAR_OP","String","startTimestamp","config","angularVersion","_metadata","sdk","packages","version","SDK_VERSION","VERSION","major","parseInt","warn","setContext","browserInit"],"mappings":"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","sourcesContent":["export const ANGULAR_ROUTING_OP = 'ui.angular.routing';\n\nexport const ANGULAR_INIT_OP = 'ui.angular.init';\n\nexport const ANGULAR_OP = 'ui.angular';\n\n/**\n * Minimum Angular version this SDK supports\n */\nexport const ANGULAR_MINIMUM_VERSION = 10;\n","/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * We define \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during our, or the user's\n * build process. Take care when introducing new flags - they must not throw if they are not replaced. See the Debug\n * Build Flags section in CONTRIBUTING.md.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n","// That's the `global.Zone` exposed when the `zone.js` package is used.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ndeclare const Zone: any;\n\n// There're 2 types of Angular applications:\n// 1) zone-full (by default)\n// 2) zone-less\n// The developer can avoid importing the `zone.js` package and tells Angular that\n// he is responsible for running the change detection by himself. This is done by\n// \"nooping\" the zone through `CompilerOptions` when bootstrapping the root module.\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nconst isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;\n\n/**\n * The function that does the same job as `NgZone.runOutsideAngular`.\n */\nexport function runOutsideAngular<T>(callback: () => T): T {\n  // The `Zone.root.run` basically will run the `callback` in the most parent zone.\n  // Any asynchronous API used inside the `callback` won't catch Angular's zone\n  // since `Zone.current` will reference `Zone.root`.\n  // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't\n  // trigger change detection, and `ApplicationRef.tick()` will not be run.\n  // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this\n  // will require injecting the `NgZone` facade. That will create a breaking change for\n  // projects already using the `@sentry/angular`.\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return isNgZoneEnabled ? Zone.root.run(callback) : callback();\n}\n","import { HttpErrorResponse } from '@angular/common/http';\nimport { ErrorHandler as AngularErrorHandler, Inject, Injectable } from '@angular/core';\nimport * as Sentry from '@sentry/browser';\nimport { captureException } from '@sentry/browser';\nimport { addExceptionMechanism } from '@sentry/utils';\n\nimport { runOutsideAngular } from './zone';\n\n/**\n * Options used to configure the behavior of the Angular ErrorHandler.\n */\nexport interface ErrorHandlerOptions {\n  logErrors?: boolean;\n  showDialog?: boolean;\n  dialogOptions?: Sentry.ReportDialogOptions;\n  /**\n   * Custom implementation of error extraction from the raw value captured by the Angular.\n   * @param error Value captured by Angular's ErrorHandler provider\n   * @param defaultExtractor Default implementation that can be used as the fallback in case of custom implementation\n   */\n  extractor?(error: unknown, defaultExtractor: (error: unknown) => unknown): unknown;\n}\n\n/**\n * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.\n */\n@Injectable({ providedIn: 'root' })\nclass SentryErrorHandler implements AngularErrorHandler {\n  protected readonly _options: ErrorHandlerOptions;\n\n  public constructor(@Inject('errorHandlerOptions') options?: ErrorHandlerOptions) {\n    this._options = {\n      logErrors: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Method called for every value captured through the ErrorHandler\n   */\n  public handleError(error: unknown): void {\n    const extractedError = this._extractError(error) || 'Handled unknown error';\n\n    // Capture handled exception and send it to Sentry.\n    const eventId = runOutsideAngular(() =>\n      captureException(extractedError, scope => {\n        scope.addEventProcessor(event => {\n          addExceptionMechanism(event, {\n            type: 'angular',\n            handled: false,\n          });\n\n          return event;\n        });\n\n        return scope;\n      }),\n    );\n\n    // When in development mode, log the error to console for immediate feedback.\n    if (this._options.logErrors) {\n      // eslint-disable-next-line no-console\n      console.error(extractedError);\n    }\n\n    // Optionally show user dialog to provide details on what happened.\n    if (this._options.showDialog) {\n      Sentry.showReportDialog({ ...this._options.dialogOptions, eventId });\n    }\n  }\n\n  /**\n   * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.\n   */\n  protected _extractError(error: unknown): unknown {\n    // Allow custom overrides of extracting function\n    if (this._options.extractor) {\n      const defaultExtractor = this._defaultExtractor.bind(this);\n      return this._options.extractor(error, defaultExtractor);\n    }\n\n    return this._defaultExtractor(error);\n  }\n\n  /**\n   * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.\n   */\n  protected _defaultExtractor(errorCandidate: unknown): unknown {\n    let error = errorCandidate;\n\n    // Try to unwrap zone.js error.\n    // https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts\n    if (error && (error as { ngOriginalError: Error }).ngOriginalError) {\n      error = (error as { ngOriginalError: Error }).ngOriginalError;\n    }\n\n    // We can handle messages and Error objects directly.\n    if (typeof error === 'string' || error instanceof Error) {\n      return error;\n    }\n\n    // If it's http module error, extract as much information from it as we can.\n    if (error instanceof HttpErrorResponse) {\n      // The `error` property of http exception can be either an `Error` object, which we can use directly...\n      if (error.error instanceof Error) {\n        return error.error;\n      }\n\n      // ... or an`ErrorEvent`, which can provide us with the message but no stack...\n      if (error.error instanceof ErrorEvent && error.error.message) {\n        return error.error.message;\n      }\n\n      // ...or the request body itself, which we can use as a message instead.\n      if (typeof error.error === 'string') {\n        return `Server returned code ${error.status} with body \"${error.error}\"`;\n      }\n\n      // If we don't have any detailed information, fallback to the request message itself.\n      return error.message;\n    }\n\n    // Nothing was extracted, fallback to default error message.\n    return null;\n  }\n}\n\n/**\n * Factory function that creates an instance of a preconfigured ErrorHandler provider.\n */\nfunction createErrorHandler(config?: ErrorHandlerOptions): SentryErrorHandler {\n  return new SentryErrorHandler(config);\n}\n\nexport { createErrorHandler, SentryErrorHandler };\n","/* eslint-disable max-lines */\nimport { AfterViewInit, Directive, Injectable, Input, NgModule, OnDestroy, OnInit } from '@angular/core';\nimport { ActivatedRouteSnapshot, Event, NavigationEnd, NavigationStart, ResolveEnd, Router } from '@angular/router';\nimport { getCurrentHub } from '@sentry/browser';\nimport { Span, Transaction, TransactionContext } from '@sentry/types';\nimport { getGlobalObject, logger, stripUrlQueryAndFragment, timestampWithMs } from '@sentry/utils';\nimport { Observable, Subscription } from 'rxjs';\nimport { filter, tap } from 'rxjs/operators';\n\nimport { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { runOutsideAngular } from './zone';\n\nlet instrumentationInitialized: boolean;\nlet stashedStartTransaction: (context: TransactionContext) => Transaction | undefined;\nlet stashedStartTransactionOnLocationChange: boolean;\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Creates routing instrumentation for Angular Router.\n */\nexport function routingInstrumentation(\n  customStartTransaction: (context: TransactionContext) => Transaction | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  instrumentationInitialized = true;\n  stashedStartTransaction = customStartTransaction;\n  stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;\n\n  if (startTransactionOnPageLoad && global && global.location) {\n    customStartTransaction({\n      name: global.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n}\n\nexport const instrumentAngularRouting = routingInstrumentation;\n\n/**\n * Grabs active transaction off scope\n */\nexport function getActiveTransaction(): Transaction | undefined {\n  const currentHub = getCurrentHub();\n\n  if (currentHub) {\n    const scope = currentHub.getScope();\n    if (scope) {\n      return scope.getTransaction();\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.\n * Creates a new transaction for every route change and measures a duration of routing process.\n */\n@Injectable({ providedIn: 'root' })\nexport class TraceService implements OnDestroy {\n  public navStart$: Observable<Event> = this._router.events.pipe(\n    filter((event): event is NavigationStart => event instanceof NavigationStart),\n    tap(navigationEvent => {\n      if (!instrumentationInitialized) {\n        IS_DEBUG_BUILD &&\n          logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');\n        return;\n      }\n\n      const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);\n      let activeTransaction = getActiveTransaction();\n\n      if (!activeTransaction && stashedStartTransactionOnLocationChange) {\n        activeTransaction = stashedStartTransaction({\n          name: strippedUrl,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n\n      if (activeTransaction) {\n        if (this._routingSpan) {\n          this._routingSpan.finish();\n        }\n        this._routingSpan = activeTransaction.startChild({\n          description: `${navigationEvent.url}`,\n          op: ANGULAR_ROUTING_OP,\n          tags: {\n            'routing.instrumentation': '@sentry/angular',\n            url: strippedUrl,\n            ...(navigationEvent.navigationTrigger && {\n              navigationTrigger: navigationEvent.navigationTrigger,\n            }),\n          },\n        });\n      }\n    }),\n  );\n\n  // The ResolveEnd event is fired when the Angular router has resolved the URL and\n  // the parameter<->value mapping. It holds the new resolved router state with\n  // the mapping and the new URL.\n  // Only After this event, the route is activated, meaning that the transaction\n  // can be updated with the parameterized route name before e.g. the route's root\n  // component is initialized. This should be early enough before outgoing requests\n  // are made from the new route, with the exceptions of requests being made during\n  // a navigation.\n  public resEnd$: Observable<Event> = this._router.events.pipe(\n    filter((event): event is ResolveEnd => event instanceof ResolveEnd),\n    tap(event => {\n      const route = getParameterizedRouteFromSnapshot(event.state.root);\n\n      const transaction = getActiveTransaction();\n      // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?\n      if (transaction && transaction.metadata.source === 'url') {\n        transaction.setName(route, 'route');\n      }\n    }),\n  );\n\n  public navEnd$: Observable<Event> = this._router.events.pipe(\n    filter(event => event instanceof NavigationEnd),\n    tap(() => {\n      if (this._routingSpan) {\n        runOutsideAngular(() => {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._routingSpan!.finish();\n        });\n        this._routingSpan = null;\n      }\n    }),\n  );\n\n  private _routingSpan: Span | null = null;\n\n  private _subscription: Subscription = new Subscription();\n\n  public constructor(private readonly _router: Router) {\n    this._subscription.add(this.navStart$.subscribe());\n    this._subscription.add(this.resEnd$.subscribe());\n    this._subscription.add(this.navEnd$.subscribe());\n  }\n\n  /**\n   * This is used to prevent memory leaks when the root view is created and destroyed multiple times,\n   * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.\n   */\n  public ngOnDestroy(): void {\n    this._subscription.unsubscribe();\n  }\n}\n\nconst UNKNOWN_COMPONENT = 'unknown';\n\n/**\n * A directive that can be used to capture initialization lifecycle of the whole component.\n */\n@Directive({ selector: '[trace]' })\nexport class TraceDirective implements OnInit, AfterViewInit {\n  @Input('trace') public componentName: string = UNKNOWN_COMPONENT;\n\n  private _tracingSpan?: Span;\n\n  /**\n   * Implementation of OnInit lifecycle method\n   * @inheritdoc\n   */\n  public ngOnInit(): void {\n    const activeTransaction = getActiveTransaction();\n    if (activeTransaction) {\n      this._tracingSpan = activeTransaction.startChild({\n        description: `<${this.componentName}>`,\n        op: ANGULAR_INIT_OP,\n      });\n    }\n  }\n\n  /**\n   * Implementation of AfterViewInit lifecycle method\n   * @inheritdoc\n   */\n  public ngAfterViewInit(): void {\n    if (this._tracingSpan) {\n      this._tracingSpan.finish();\n    }\n  }\n}\n\n/**\n * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.\n */\n@NgModule({\n  declarations: [TraceDirective],\n  exports: [TraceDirective],\n})\nexport class TraceModule {}\n\n/**\n * Decorator function that can be used to capture initialization lifecycle of the whole component.\n */\nexport function TraceClassDecorator(): ClassDecorator {\n  let tracingSpan: Span;\n\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n  return target => {\n    const originalOnInit = target.prototype.ngOnInit;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    target.prototype.ngOnInit = function (...args: any[]): ReturnType<typeof originalOnInit> {\n      const activeTransaction = getActiveTransaction();\n      if (activeTransaction) {\n        tracingSpan = activeTransaction.startChild({\n          description: `<${target.name}>`,\n          op: ANGULAR_INIT_OP,\n        });\n      }\n      if (originalOnInit) {\n        return originalOnInit.apply(this, args);\n      }\n    };\n\n    const originalAfterViewInit = target.prototype.ngAfterViewInit;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    target.prototype.ngAfterViewInit = function (...args: any[]): ReturnType<typeof originalAfterViewInit> {\n      if (tracingSpan) {\n        tracingSpan.finish();\n      }\n      if (originalAfterViewInit) {\n        return originalAfterViewInit.apply(this, args);\n      }\n    };\n  };\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n}\n\n/**\n * Decorator function that can be used to capture a single lifecycle methods of the component.\n */\nexport function TraceMethodDecorator(): MethodDecorator {\n  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types\n  return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => {\n    const originalMethod = descriptor.value;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    descriptor.value = function (...args: any[]): ReturnType<typeof originalMethod> {\n      const now = timestampWithMs();\n      const activeTransaction = getActiveTransaction();\n      if (activeTransaction) {\n        activeTransaction.startChild({\n          description: `<${target.constructor.name}>`,\n          endTimestamp: now,\n          op: `${ANGULAR_OP}.${String(propertyKey)}`,\n          startTimestamp: now,\n        });\n      }\n      if (originalMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        return originalMethod.apply(this, args);\n      }\n    };\n    return descriptor;\n  };\n}\n\n/**\n * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's\n * child route with its parent to produce the complete parameterized URL of the activated route.\n * This happens recursively until the last child (i.e. the end of the URL) is reached.\n *\n * @param route the ActivatedRouteSnapshot of which its path and its child's path is concantenated\n *\n * @returns the concatenated parameterzited route string\n */\nexport function getParameterizedRouteFromSnapshot(route?: ActivatedRouteSnapshot | null): string {\n  const path = route && route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path;\n  if (!path) {\n    return '/';\n  }\n  return `/${path}${getParameterizedRouteFromSnapshot(route && route.firstChild)}`;\n}\n","import { VERSION } from '@angular/core';\nimport { BrowserOptions, init as browserInit, SDK_VERSION, setContext } from '@sentry/browser';\nimport { logger } from '@sentry/utils';\n\nimport { ANGULAR_MINIMUM_VERSION } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\n\n/**\n * Inits the Angular SDK\n */\nexport function init(options: BrowserOptions): void {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk = {\n    name: 'sentry.javascript.angular',\n    packages: [\n      {\n        name: 'npm:@sentry/angular',\n        version: SDK_VERSION,\n      },\n    ],\n    version: SDK_VERSION,\n  };\n\n  checkAndSetAngularVersion();\n  browserInit(options);\n}\n\nfunction checkAndSetAngularVersion(): void {\n  const angularVersion = VERSION && VERSION.major ? parseInt(VERSION.major, 10) : undefined;\n\n  if (angularVersion) {\n    if (angularVersion < ANGULAR_MINIMUM_VERSION) {\n      IS_DEBUG_BUILD &&\n        logger.warn(\n          `The Sentry SDK does not officially support Angular ${angularVersion}.`,\n          `This version of the Sentry SDK supports Angular ${ANGULAR_MINIMUM_VERSION} and above.`,\n          'Please consider upgrading your Angular version or downgrading the Sentry SDK.',\n        );\n    }\n    setContext('angular', { version: angularVersion });\n  }\n}\n"]}