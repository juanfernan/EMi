/* eslint-disable max-lines */
import { Directive, Injectable, Input, NgModule } from '@angular/core';
import { NavigationEnd, NavigationStart, ResolveEnd, Router } from '@angular/router';
import { getCurrentHub } from '@sentry/browser';
import { getGlobalObject, logger, stripUrlQueryAndFragment, timestampWithMs } from '@sentry/utils';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
let stashedStartTransaction;
let stashedStartTransactionOnLocationChange;
const global = getGlobalObject();
/**
 * Creates routing instrumentation for Angular Router.
 */
export function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad && global && global.location) {
        customStartTransaction({
            name: global.location.pathname,
            op: 'pageload',
            metadata: { source: 'url' },
        });
    }
}
export const instrumentAngularRouting = routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
export function getActiveTransaction() {
    const currentHub = getCurrentHub();
    if (currentHub) {
        const scope = currentHub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            let activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                    metadata: { source: 'url' },
                });
            }
            if (activeTransaction) {
                if (this._routingSpan) {
                    this._routingSpan.finish();
                }
                this._routingSpan = activeTransaction.startChild({
                    description: `${navigationEvent.url}`,
                    op: ANGULAR_ROUTING_OP,
                    tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            const transaction = getActiveTransaction();
            // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?
            if (transaction && transaction.metadata.source === 'url') {
                transaction.setName(route, 'route');
            }
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.finish();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
TraceService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TraceService_Factory() { return new TraceService(i0.ɵɵinject(i1.Router)); }, token: TraceService, providedIn: "root" });
TraceService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TraceService.ctorParameters = () => [
    { type: Router }
];
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    constructor() {
        this.componentName = UNKNOWN_COMPONENT;
    }
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        const activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            this._tracingSpan = activeTransaction.startChild({
                description: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
            });
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            this._tracingSpan.finish();
        }
    }
}
TraceDirective.decorators = [
    { type: Directive, args: [{ selector: '[trace]' },] }
];
TraceDirective.propDecorators = {
    componentName: [{ type: Input, args: ['trace',] }]
};
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TraceDirective],
                exports: [TraceDirective],
            },] }
];
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClassDecorator() {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                tracingSpan = activeTransaction.startChild({
                    description: `<${target.name}>`,
                    op: ANGULAR_INIT_OP,
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                tracingSpan.finish();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampWithMs();
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                activeTransaction.startChild({
                    description: `<${target.constructor.name}>`,
                    endTimestamp: now,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concantenated
 *
 * @returns the concatenated parameterzited route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const path = route && route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path;
    if (!path) {
        return '/';
    }
    return `/${path}${getParameterizedRouteFromSnapshot(route && route.firstChild)}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9zZW50cnktamF2YXNjcmlwdC9zZW50cnktamF2YXNjcmlwdC9wYWNrYWdlcy9hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbInRyYWNpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsOEJBQThCO0FBQzlCLE9BQU8sRUFBaUIsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUN6RyxPQUFPLEVBQWlDLGFBQWEsRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sRUFBRSx3QkFBd0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkcsT0FBTyxFQUFjLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLE9BQU8sRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzlFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDekMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sUUFBUSxDQUFDOzs7QUFFM0MsSUFBSSwwQkFBbUMsQ0FBQztBQUN4QyxJQUFJLHVCQUFpRixDQUFDO0FBQ3RGLElBQUksdUNBQWdELENBQUM7QUFFckQsTUFBTSxNQUFNLEdBQUcsZUFBZSxFQUFVLENBQUM7QUFFekM7O0dBRUc7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQ3BDLHNCQUFnRixFQUNoRiw2QkFBc0MsSUFBSSxFQUMxQyxtQ0FBNEMsSUFBSTtJQUVoRCwwQkFBMEIsR0FBRyxJQUFJ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R0FBRyxHQUFHLGVBQWUsRUFBRSxDQUFDO1lBQzlCLE1BQU0saUJBQWlCLEdBQUcsb0JBQW9CLEVBQUUsQ0FBQztZQUNqRCxJQUFJLGlCQUFpQixFQUFFO2dCQUNyQixpQkFBaUIsQ0FBQyxVQUFVLENBQUM7b0JBQzNCLFdBQVcsRUFBRSxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHO29CQUMzQyxZQUFZLEVBQUUsR0FBRztvQkFDakIsRUFBRSxFQUFFLEdBQUcsVUFBVSxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDMUMsY0FBYyxFQUFFLEdBQUc7aUJBQ3BCLENBQUMsQ0FBQzthQUNKO1lBQ0QsSUFBSSxjQUFjLEVBQUU7Z0JBQ2xCLHNFQUFzRTtnQkFDdEUsT0FBTyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN6QztRQUNILENBQUMsQ0FBQztRQUNGLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxpQ0FBaUMsQ0FBQyxLQUFxQztJQUNyRixNQUFNLElBQUksR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDNUcsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFDRCxPQUFPLElBQUksSUFBSSxHQUFHLGlDQUFpQyxDQUFDLEtBQUssSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztBQUNuRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEluamVjdGFibGUsIElucHV0LCBOZ01vZHVsZSwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIEV2ZW50LCBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uU3RhcnQsIFJlc29sdmVFbmQsIFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBnZXRDdXJyZW50SHViIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB7IFNwYW4sIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkNvbnRleHQgfSBmcm9tICdAc2VudHJ5L3R5cGVzJztcbmltcG9ydCB7IGdldEdsb2JhbE9iamVjdCwgbG9nZ2VyLCBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQsIHRpbWVzdGFtcFdpdGhNcyB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQU5HVUxBUl9JTklUX09QLCBBTkdVTEFSX09QLCBBTkdVTEFSX1JPVVRJTkdfT1AgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBJU19ERUJVR19CVUlMRCB9IGZyb20gJy4vZmxhZ3MnO1xuaW1wb3J0IHsgcnVuT3V0c2lkZUFuZ3VsYXIgfSBmcm9tICcuL3pvbmUnO1xuXG5sZXQgaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5sZXQgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb246IChjb250ZXh0OiBUcmFuc2FjdGlvbkNvbnRleHQpID0+IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkO1xubGV0IHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZTogYm9vbGVhbjtcblxuY29uc3QgZ2xvYmFsID0gZ2V0R2xvYmFsT2JqZWN0PFdpbmRvdz4oKTtcblxuLyoqXG4gKiBDcmVhdGVzIHJvdXRpbmcgaW5zdHJ1bWVudGF0aW9uIGZvciBBbmd1bGFyIFJvdXRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdXRpbmdJbnN0cnVtZW50YXRpb24oXG4gIGN1c3RvbVN0YXJ0VHJhbnNhY3Rpb246IChjb250ZXh0OiBUcmFuc2FjdGlvbkNvbnRleHQpID0+IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLFxuICBzdGFydFRyYW5zYWN0aW9uT25QYWdlTG9hZDogYm9vbGVhbiA9IHRydWUsXG4gIHN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlOiBib29sZWFuID0gdHJ1ZSxcbik6IHZvaWQge1xuICBpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XG4gIHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uID0gY3VzdG9tU3RhcnRUcmFuc2FjdGlvbjtcbiAgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlID0gc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2U7XG5cbiAgaWYgKHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkICYmIGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24pIHtcbiAgICBjdXN0b21TdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgIG5hbWU6IGdsb2JhbC5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIG9wOiAncGFnZWxvYWQnLFxuICAgICAgbWV0YWRhdGE6IHsgc291cmNlOiAndXJsJyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbnN0cnVtZW50QW5ndWxhclJvdXRpbmcgPSByb3V0aW5nSW5zdHJ1bWVudGF0aW9uO1xuXG4vKipcbiAqIEdyYWJzIGFjdGl2ZSB0cmFuc2FjdGlvbiBvZmYgc2NvcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk6IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgY3VycmVudEh1YiA9IGdldEN1cnJlbnRIdWIoKTtcblxuICBpZiAoY3VycmVudEh1Yikge1xuICAgIGNvbnN0IHNjb3BlID0gY3VycmVudEh1Yi5nZXRTY29wZSgpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgcmV0dXJuIHNjb3BlLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBbmd1bGFyJ3MgU2VydmljZSByZXNwb25zaWJsZSBmb3IgaG9va2luZyBpbnRvIEFuZ3VsYXIgUm91dGVyIGFuZCB0cmFja2luZyBjdXJyZW50IG5hdmlnYXRpb24gcHJvY2Vzcy5cbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24gZm9yIGV2ZXJ5IHJvdXRlIGNoYW5nZSBhbmQgbWVhc3VyZXMgYSBkdXJhdGlvbiBvZiByb3V0aW5nIHByb2Nlc3MuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHVibGljIG5hdlN0YXJ0JDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIE5hdmlnYXRpb25TdGFydCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCksXG4gICAgdGFwKG5hdmlnYXRpb25FdmVudCA9PiB7XG4gICAgICBpZiAoIWluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgICAgIElTX0RFQlVHX0JVSUxEICYmXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKCdBbmd1bGFyIGludGVncmF0aW9uIGhhcyB0cmFjaW5nIGVuYWJsZWQsIGJ1dCBUcmFjaW5nIGludGVncmF0aW9uIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyaXBwZWRVcmwgPSBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQobmF2aWdhdGlvbkV2ZW50LnVybCk7XG4gICAgICBsZXQgYWN0aXZlVHJhbnNhY3Rpb24gPSBnZXRBY3RpdmVUcmFuc2FjdGlvbigpO1xuXG4gICAgICBpZiAoIWFjdGl2ZVRyYW5zYWN0aW9uICYmIHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZSkge1xuICAgICAgICBhY3RpdmVUcmFuc2FjdGlvbiA9IHN0YXNoZWRTdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICBuYW1lOiBzdHJpcHBlZFVybCxcbiAgICAgICAgICBvcDogJ25hdmlnYXRpb24nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7IHNvdXJjZTogJ3VybCcgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgICB0aGlzLl9yb3V0aW5nU3Bhbi5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3V0aW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtuYXZpZ2F0aW9uRXZlbnQudXJsfWAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfUk9VVElOR19PUCxcbiAgICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgICAncm91dGluZy5pbnN0cnVtZW50YXRpb24nOiAnQHNlbnRyeS9hbmd1bGFyJyxcbiAgICAgICAgICAgIHVybDogc3RyaXBwZWRVcmwsXG4gICAgICAgICAgICAuLi4obmF2aWdhdGlvbkV2ZW50Lm5hdmlnYXRpb25UcmlnZ2VyICYmIHtcbiAgICAgICAgICAgICAgbmF2aWdhdGlvblRyaWdnZXI6IG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIC8vIFRoZSBSZXNvbHZlRW5kIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIEFuZ3VsYXIgcm91dGVyIGhhcyByZXNvbHZlZCB0aGUgVVJMIGFuZFxuICAvLyB0aGUgcGFyYW1ldGVyPC0+dmFsdWUgbWFwcGluZy4gSXQgaG9sZHMgdGhlIG5ldyByZXNvbHZlZCByb3V0ZXIgc3RhdGUgd2l0aFxuICAvLyB0aGUgbWFwcGluZyBhbmQgdGhlIG5ldyBVUkwuXG4gIC8vIE9ubHkgQWZ0ZXIgdGhpcyBldmVudCwgdGhlIHJvdXRlIGlzIGFjdGl2YXRlZCwgbWVhbmluZyB0aGF0IHRoZSB0cmFuc2FjdGlvblxuICAvLyBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIG5hbWUgYmVmb3JlIGUuZy4gdGhlIHJvdXRlJ3Mgcm9vdFxuICAvLyBjb21wb25lbnQgaXMgaW5pdGlhbGl6ZWQuIFRoaXMgc2hvdWxkIGJlIGVhcmx5IGVub3VnaCBiZWZvcmUgb3V0Z29pbmcgcmVxdWVzdHNcbiAgLy8gYXJlIG1hZGUgZnJvbSB0aGUgbmV3IHJvdXRlLCB3aXRoIHRoZSBleGNlcHRpb25zIG9mIHJlcXVlc3RzIGJlaW5nIG1hZGUgZHVyaW5nXG4gIC8vIGEgbmF2aWdhdGlvbi5cbiAgcHVibGljIHJlc0VuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcigoZXZlbnQpOiBldmVudCBpcyBSZXNvbHZlRW5kID0+IGV2ZW50IGluc3RhbmNlb2YgUmVzb2x2ZUVuZCksXG4gICAgdGFwKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHJvdXRlID0gZ2V0UGFyYW1ldGVyaXplZFJvdXRlRnJvbVNuYXBzaG90KGV2ZW50LnN0YXRlLnJvb3QpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICAvLyBUT0RPICh2OCAvICM1NDE2KTogcmV2aXNpdCB0aGUgc291cmNlIGNvbmRpdGlvbi4gRG8gd2Ugd2FudCB0byBtYWtlIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIHRoZSBkZWZhdWx0P1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLm1ldGFkYXRhLnNvdXJjZSA9PT0gJ3VybCcpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2V0TmFtZShyb3V0ZSwgJ3JvdXRlJyk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgcHVibGljIG5hdkVuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpLFxuICAgIHRhcCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4hLmZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIHByaXZhdGUgX3JvdXRpbmdTcGFuOiBTcGFuIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3JvdXRlcjogUm91dGVyKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLm5hdlN0YXJ0JC5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLnJlc0VuZCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZFbmQkLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiB0aGUgcm9vdCB2aWV3IGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBtdWx0aXBsZSB0aW1lcyxcbiAgICogc2luY2UgYHN1YnNjcmliZWAgY2FsbGJhY2tzIGNhcHR1cmUgYHRoaXNgIGFuZCBwcmV2ZW50IG1hbnkgcmVzb3VyY2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG5jb25zdCBVTktOT1dOX0NPTVBPTkVOVCA9ICd1bmtub3duJztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyA9IFVOS05PV05fQ09NUE9ORU5UO1xuXG4gIHByaXZhdGUgX3RyYWNpbmdTcGFuPzogU3BhbjtcblxuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgT25Jbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICBkZXNjcmlwdGlvbjogYDwke3RoaXMuY29tcG9uZW50TmFtZX0+YCxcbiAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RyYWNpbmdTcGFuKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3Bhbi5maW5pc2goKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGluaXRpYWxpemF0aW9uIGxpZmVjeWNsZSBvZiB0aGUgd2hvbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gVHJhY2VDbGFzc0RlY29yYXRvcigpOiBDbGFzc0RlY29yYXRvciB7XG4gIGxldCB0cmFjaW5nU3BhbjogU3BhbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0YXJnZXQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxPbkluaXQ+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zYWN0aW9uID0gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTtcbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICB0cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgPCR7dGFyZ2V0Lm5hbWV9PmAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxPbkluaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Jbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEFmdGVyVmlld0luaXQgPSB0YXJnZXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxBZnRlclZpZXdJbml0PiB7XG4gICAgICBpZiAodHJhY2luZ1NwYW4pIHtcbiAgICAgICAgdHJhY2luZ1NwYW4uZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxBZnRlclZpZXdJbml0KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEFmdGVyVmlld0luaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGEgc2luZ2xlIGxpZmVjeWNsZSBtZXRob2RzIG9mIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZU1ldGhvZERlY29yYXRvcigpOiBNZXRob2REZWNvcmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlLCBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE1ldGhvZD4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZXN0YW1wV2l0aE1zKCk7XG4gICAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGA8JHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0+YCxcbiAgICAgICAgICBlbmRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICBvcDogYCR7QU5HVUxBUl9PUH0uJHtTdHJpbmcocHJvcGVydHlLZXkpfWAsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBmcm9tIGEgZ2l2ZW4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSBzbmFwc2hvdCdzXG4gKiBjaGlsZCByb3V0ZSB3aXRoIGl0cyBwYXJlbnQgdG8gcHJvZHVjZSB0aGUgY29tcGxldGUgcGFyYW1ldGVyaXplZCBVUkwgb2YgdGhlIGFjdGl2YXRlZCByb3V0ZS5cbiAqIFRoaXMgaGFwcGVucyByZWN1cnNpdmVseSB1bnRpbCB0aGUgbGFzdCBjaGlsZCAoaS5lLiB0aGUgZW5kIG9mIHRoZSBVUkwpIGlzIHJlYWNoZWQuXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IG9mIHdoaWNoIGl0cyBwYXRoIGFuZCBpdHMgY2hpbGQncyBwYXRoIGlzIGNvbmNhbnRlbmF0ZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgY29uY2F0ZW5hdGVkIHBhcmFtZXRlcnppdGVkIHJvdXRlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyaXplZFJvdXRlRnJvbVNuYXBzaG90KHJvdXRlPzogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB8IG51bGwpOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID0gcm91dGUgJiYgcm91dGUuZmlyc3RDaGlsZCAmJiByb3V0ZS5maXJzdENoaWxkLnJvdXRlQ29uZmlnICYmIHJvdXRlLmZpcnN0Q2hpbGQucm91dGVDb25maWcucGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gYC8ke3BhdGh9JHtnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3Qocm91dGUgJiYgcm91dGUuZmlyc3RDaGlsZCl9YDtcbn1cbiJdfQ==